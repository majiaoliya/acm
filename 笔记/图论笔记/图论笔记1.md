握手定理: 无向图的度数=边数的2倍









##### luogu1113简单dp+拓扑排序(好题[我的代码](/home/majiao/桌面/Link to 刷题/hdu/第一阶段/拓扑排序/luogu1113拓扑+简单dp/))

> 给定一个有向图(无环),有点权,求点权和最大的一条路径

* 设$u$点的前驱为$pre[i]$ 
* 则转移为$d[u] = max(dp[u], dp[pre[i]]+w[u])$
* 于是可以一边拓扑,一边$dp$



##### luogu4017好题

> 给你一个食物网，你要求出这个食物网中最大食物链的数量。

- 对于入度为$0$ 的点 初始化为1

$$
设f[i]为第i个点的路径数量,\\pre为i的前驱节点\\
cnt为i的前驱节点个数\\
则~f[i] = \sum_{k=0}^{cnt}f[pre[k]~]
$$

$$
设f[i]为第i个点的路径数量,\\pre为i的前驱节点\\
cnt为i的前驱节点个数\\
则~f[i] = \sum_{k=0}^{cnt}f[pre[k]~]\\
ans=\sum_{出度=0}{f[x]}
$$

$\color{\red}如果存在重边的话我认为应该是乘法原理, 学弟说是累加就行, 目前我无法判断是谁对谁错$



##### uva506(WA了一亿年)

> 紫书173页例题,刘汝佳钦点的**必写题**
>
> 给定安装包依赖关系,和一些命令
>
> $install~~x$,安装$x$和$x$依赖的包
>
> $remove~x$,删除$x$,如果$x$还被其他软件需要就不删,
>
> 否则删除$x$和$x$的所有依赖
>
> $list$,打印当前安装的所有依赖包

我的$WA$思路:

* $dfs$后序安装,记得更新子节点的入度
* $dfs$先序删除,把非隐式安装且入度为$0$级联删除,

书上思路: 

* 建两个图$vector<int> depend[~], depend2[~]$
* 一个正向图,一个反向图, 用$status[i]$表示第$i$点的状态





##### luogu1137拓扑序+简单dp

> 给定一张$DAG$(有向无环图),每个点点权都是$1$,对于每个点$V_i$,
>
> 可以任挑一个起点$S_i$走到$V_i$,使得路径$S_i$到$V_i$的点权和最大

* $dp[i] = max(dp[i],dp[pre]+1)$
* 学弟神仙级别思路 : 把图反向存储  对于每一个点当做树根  就变成 求这个点的树高



##### UVA10129 有向图的欧拉回路[代码](/home/majiao/my_mount/Xubuntu_Work_Space/From_Xubuntu/codeTest_2019_2_21/刷题/hdu/第一阶段/dfs/uva10129有向图欧拉回路)

> 给定多个单词s1,s2,s3...sn, 如果s[i]的开头等于s[j]的结尾,就连边,问是否能一笔画

* 有向图存在欧拉回路:

  * 底图(无视方向后的图) 联通

  * 最多2个入度不相等的点$U,V$,且其中一个入度比出度大1,另一个出度比入度大1

    ```c++
    int _in = 0, _out = 0;
    for(int i='a'; i<='z'; i++) {
      if(vis[i]) return false;
      if(ind[i] != outd[i]) {
        if(ind[i]-outd[i] == 1) 
          _in ++;
        else if(outd[i]-ind[i] == 1) 
          _out ++;
        else return false;
      }
    }
    if((_in==1&&_out==1) ||
       (_in==0&&_out==0)) return true;
    return false;

    ```

    ​