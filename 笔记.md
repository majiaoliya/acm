### luogu1036选数(dfs经典题)

> 从N个数字中选K个
>
> ```c++
> void dfs(int level, int sum) {
> 	if(level > m) {
> 		if(is_prime(sum)) ans ++;
> 		return ;
> 	}
> 	for(int i=level; i<=n; i++) { //不降原则
> 		if(vis[i] || i<rs[level-1]) continue ;
> 		vis[i] = true;
> 		rs[level] = i;
> 		dfs(level+1, sum+a[i]);
> 		vis[i] = false;
> 	}
> }
> ```
>
> 





### luogu1618三连击

* 不知道为什么要用$j=i/a*b,  k=i/a*c$
* 不知道为什么要特判$123~456~789$



### 2020-3-11 luogu3799排列组合好题

> 有n根木棒，现在从中选***4***根，想要组成一个正三角形，问有几种选法？

* 可以发现一定有**2**根是等长的X，剩下**2**根的长度和为(Y+Z) = X

* 枚举X ,Y， 求他们的排列组合**注意模1e9+7**

$$
第一层for枚举5000内的长度X~对于X~tmp=C_{cnt[X]}^{2}\\
~~ 第二层for枚举Y~ans+=tmp*C_{cnt[Y]}^{1}*C_{cnt[X-Y]}^{1}
$$






### 2020-3-10  luogu2241统计方块(好题)

> **求n*m的网格中的长方形,正方形的个数**

* **先排列组合求 矩形 的个数X = $C_{N+1}^{2}~*~C_{M+1}^{2}$**


* **公式 $C_{N}^{2} = \frac{N*(N-1)}{2}$**
* $C_{N+1}^{2}~*~C_{M+1}^{2}$ = $(\frac{(M+1)*M}{2}) * (\frac{(N+1)*N}{2})$
* 对于一个边长为i的正方形有$(N-i+1)*(M-i+1)$ 种放置方法, 所以


$$
正方形个数~ = ~\sum_{i=1}^{min(N, M)} {(N-i+1)*(M-i+1)}
$$

* 最后正方形个数y,  长方形个数(x-y)








### luogu1012贪心

> 给定多个数字,把他们拼成一个最大的数字
>
> 13, 312, 343可以拼成34331213 
>
> + 先排序,打印排好序的数组就行
>
> + ```c++
>   bool cmp(string& x, string& y) { 
>   return x+y > y+x;
>   }
>   ```
> ```
>
> ```
>
> ```
>
> ```











### luogu5143大水题 

> 按z坐标排序,把距离加起来就行了

$$
三维点的公式距离
\sqrt{(x_i-x_j)^2+(y_i-y_j)^2+(z_i-z_j)^2}
$$






### 2020-3-9 luogu1923[好题]  区间k小值$\color{red}注意$

> **给定5e6个数字, 求第k小的值(k从0开始)**
>
> + ~~维护一个堆,开O2卡过去了~~
> + $\color{red}正解是用快排原理+分治  或主席树(未看懂)$
> + **或者用STL神奇的nth_element(begin,nth,end,compare);**





### 2020-3-9 luogu1271[深基] 选举学生会

> **桶排序 就是统计每个数字的出现次数 然后打印**











### 2020-3-9 luoguP1563 玩具小人藏眼镜

> **模拟好题(~~歌上唱有~~)  围成圈的小人 有人向里,有人向外**
>
> **如果一个人向外,则他的左右要反过来(可以用亦或取反)**
>
> ```c++
> while(m--) {
> 	int K, dir;
> 	scanf("%d %d ", &dir, &K);
> 	K %= n;
> 	if(a[now].dir) //如果朝外,就把左右调换
>       dir = !dir;
> 	if(RIG(dir)) //右加左减
> 		now = (now+K) % n;
> 	 else 
> 		now = (now+n-K) % n;
> }
> ```
>
> 







### 2020-3-9   luogu1042

> **模拟好题目,坑点很多**
>
> + 'E' 在开头,即比赛未开始 也要打印0:0 0:0
> + 11个球 第一局刚好结束,第二局要打印0:0





### 2020-3-9    luogu1217 

> **找出一亿里的回文质数(101,131,151,181 ...) **
>
> * 先找回文数, 再判断是不是质素
>
> * 产生回文数方法
>
> * ```c++
>   for (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数
>    for (d2 = 0; d2 <= 9; d2++) {
>      for (d3 = 0; d3 <= 9; d3++) {
>        num = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)
>      }
>    }
>   }
>   ```
> ```
>
> ```
>
> * ```c++
>   void dfs(int now, int level) { //回文数字的搜索 有点问题 缺个11 特判一下
>   if(level > max_level) {
>   	int tmp = now/10, num = now;
>   	while(tmp) {
>   		num = num * 10 + (tmp%10);
>   		tmp /= 10;
>   	}
>   	if(check(num)) que.push(num);
>   	return ;
>   }
>   for(int i=0; i<10; i++) {
>   	dfs(now*10 + i, level+1);
>   } 
>   }
>   ```
> ```
>
> ```